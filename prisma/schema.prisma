// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              Int @id @default(autoincrement())
  username        String @unique // unique username
  firstname       String // wenn kein ? dann ist es ein Pflichtfeld
  lastname        String // wenn kein ? dann ist es ein Pflichtfeld
  birthdate       DateTime
  email           String @unique // needed for verification or restoring
  phone           String // for 2FA // hier wird eine Blacklist angelegt zur Blockierung von Account
  role            UserRoles @default(ADULT) // niedrigste sicherheit da wird auch Admin als Rollen speichern
  password        String // hashed password

  userFile        UserFile? @relation("UserFile", fields: [userFileId], references: [id]) // id of the userFile
  userFileId      Int? // wird angelegt wenn beschwerden gegen einen User vorliegen
  
  // Relations
  // Bidirektionale Freundschaft: explizit zwei Seiten definieren (self relation!)

  friends         Friendship[] @relation("UserFriendship")  

  sendFriendRequests     FriendRequest[] @relation("SentRequests")
  receivedFriendRequests FriendRequest[] @relation("ReceivedRequests")

  // verlinkung der Eltern
  parentOf        User[] @relation("ParentChild", references: [id])
  childOf         User[] @relation("ParentChild", references: [id])

  // rewiews (written / moderated)
  writtenComments  Comment[] @relation("AuthorComment")
  moderatedComments Comment[] @relation("ModeratorComment")

  // Articles, Posts (written / moderated)
  writtenPosts    Post[] @relation("AuthorPosts")
  moderatedPosts   Post[] @relation("ModeratorPosts")

  // Admin Meta

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  verified        Boolean @default(false) // means this user has verified his email
  isDeleted       Boolean @default(false)
  deletedAt       DateTime?
  deletedBy       Int? // userId
  // userId -> hier wird dann eingetragen wer den User gelöscht hat
  deletedByUser   User? @relation("DeletedByUser", fields: [deletedBy], references: [id]) 

  deleteReason    String?
  deactivated     Boolean @default(false)

  // besonderheiten für Autoren

  // hier wird dann eingetragen ob er sich beworben hat, ob er angenommen wurde, ob er abgelehnt wurde (Bewerbung, angenommen, abgelehnt)
  status          Status @default(PENDING) // Bewerbung, angenommen, abgelehnt
  authorizedBy    Int? // userId -> hier wird dann eingetragen wer den Autor angenommen hat
  authorizedAt    DateTime? // hier wird dann eingetragen wann der Autor angenommen wurde
  authorOf        Post[] @relation("AuthorPosts") // one to many relation
  denyingReason  String? // hier wird dann eingetragen warum der Autor abgelehnt wurde


  // besonderheiten für Moderatoren

  moderatedBy     Int? // userId -> hier wird dann eingetragen wer den Moderator angenommen hat
  // userId -> hier wird dann eingetragen wer den Moderator angenommen hat
  moderatedByUser User? @relation("ModeratedByUser", fields: [moderatedBy], references: [id])
  moderatedAt     DateTime? // hier wird dann eingetragen wann der Moderator angenommen wurde
}

enum UserRoles {
  ADULT
  CHILD
  AUTHOR
  TEST_AUTHOR
  MODERATOR
  ADMIN
}

enum Status {
  PENDING // Bewerbung
  ACCEPTED // angenommen
  REJECTED // abgelehnt
}

model Friendship {
  userId      Int
  friendId    Int
  user        User @relation("Friendship", fields: [userId], references: [id])
  friend      User @relation("Friendship", fields: [friendId], references: [id])

  @@id([friendId, userId]) // composite primary key
}

model FriendRequest {
  id             Int @id @default(autoincrement())
  sender         Int // userId -> hier wird dann eingetragen wer die Anfrage gesendet hat
  senderId       User @relation("FriendRequestFrom", fields: [sender], references: [id])
  receiver       Int // userId -> hier wird dann eingetragen wer die Anfrage empfangen hat
  receiverId     User @relation("FriendRequestTo", fields: [receiver], references: [id])
  
  status         Status @default(PENDING)
  createdAt      DateTime @default(now())
  responsedAt    DateTime @updatedAt  
}


model UserFile {
  id              Int @id @default(autoincrement())
  userId          Int
  user            User @relation("UserFile", fields: [userId], references: [id])
  tickets         Ticket[] // das genügt um die Relation zu erstellen
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt 
}

// ticket kann man im Support erstellen, und dann wird es noch eine meldefunktion geben, als Report
model Ticket {
  id             Int @id @default(autoincrement())
  userFileId     Int
  userFile       UserFile @relation("UserFile", fields: [userFileId], references: [id])
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  status         STATUS @default(OPEN)
  quickDescription String // kurze Beschreibung
  description    String // lange Beschreibung


  workedBy      Int? // userId -> hier wird dann eingetragen wer das Ticket bearbeitet hat
  workedByUser  User? @relation("WorkedByUser", fields: [workedBy], references: [id])
}

enum STATUS {
  OPEN
  CLOSED
  IN_PROGRESS
}


model Post {
  id             Int @id @default(autoincrement())
  title          String
  content        String
  image          String? // optional
  tags           String[] // array of strings
  ageRestriction Int // notwendig da wir für unterschiedliche Altersgruppen unterschiedliche Inhalte haben
  fromCertifiedAuthor Boolean @default(false) // wir wollten das Pädagische Authoren Hervorgehoben werden

  // Capital Controlling
  preCapital     Post? @relation("PostCapital", fields: [preCapitalId], references: [id])
  preCapitalId   Int? // wenn es einen Vorgänger gibt, dann wird hier der Vorgänger eingetragen
  capital        Int? // wie viel Kapital der Autor hat
  nextCapital    Post? @relation("PostCapital", fields: [nextCapitalId], references: [id])
  nextCapitalId  Int? // wenn es einen Nachfolger gibt, dann wird hier der Nachfolger eingetragen

  authorId       Int
  author         User @relation("AuthorPosts", fields: [authorId], references: [id])

  moderatorId    Int?
  moderator      User? @relation("ModeratorPosts", fields: [moderatorId], references: [id])

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  published      Boolean @default(false)
  publishedAt    DateTime?
  // userId -> hier wird dann eingetragen wer den Post veröffentlicht hat
  publishedBy    Int? // userId
  publishedByUser User? @relation("PublishedByUser", fields: [publishedBy], references: [id]) 


  // comments & Ratings

  comments       Comment[] @relation("PostComments")
  ratings        Rating[] @relation("PostRatings")

  // wichtig falls illeagaler content gemeldet wird
  isDeleted      Boolean @default(false)
  deletedAt      DateTime?
  deletedBy      Int? // userId
  deletedByUser  User? @relation("DeletedByUser", fields: [deletedBy], references: [id]) // userId -> hier wird dann eingetragen wer den Post gelöscht hat
  deleteReason   String?
}


model Comment {
  id             Int @id @default(autoincrement())
  postId         Int
  post           Post @relation("PostComments", fields: [postId], references: [id])
  userId         Int
  user           User @relation("UserComments", fields: [userId], references: [id])

  content        String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  isDeleted      Boolean @default(false)
  deletedAt      DateTime?
  deletedBy      Int? // userId
  deletedByUser  User? @relation("DeletedByUser", fields: [deletedBy], references: [id]) // userId -> hier wird dann eingetragen wer den Kommentar gelöscht hat
  deleteReason   String?
}
model Rating {
  id             Int @id @default(autoincrement())
  postId         Int
  post           Post @relation("PostRatings", fields: [postId], references: [id])
  userId         Int
  user           User @relation("UserRatings", fields: [userId], references: [id])

  rating         Int @db.Integer
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  isDeleted      Boolean @default(false)
  deletedAt      DateTime?
  deletedBy      Int? // userId
  deletedByUser  User? @relation("DeletedByUser", fields: [deletedBy], references: [id]) // userId -> hier wird dann eingetragen wer den Kommentar gelöscht hat
  deleteReason   String?
}