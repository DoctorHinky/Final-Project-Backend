generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              Int @id @default(autoincrement())
  username        String @unique // unique username
  firstname       String // wenn kein ? dann ist es ein Pflichtfeld
  lastname        String // wenn kein ? dann ist es ein Pflichtfeld
  birthdate       DateTime
  email           String @unique // needed for verification or restoring
  phone           String // for 2FA // hier wird eine Blacklist angelegt zur Blockierung von Account
  role            UserRoles @default(ADULT)
  password        String // hashed password

  // UserFile relation - fixed one-to-one relation
  userFile        UserFile? // bidirectional one-to-one relation
  userFileId      Int? @unique // wird angelegt wenn beschwerden gegen einen User vorliegen - must be unique for one-to-one

  // Relations
  // Bidirektionale Freundschaft: explizit zwei Seiten definieren (self relation!)

  friendshipInvites FriendRequest[] @relation("SendRequests") // ich habe eine Freundschaftsanfrage gesendet
  friendshipsReceived FriendRequest[] @relation("ReceivedRequest") // ich habe eine Freundschaftsanfrage erhalten

  // friendships

  friendshipInitated Friendship[] @relation("Initiator") // ich habe diese Freundschaft initiiert
  friendshipAccepted Friendship[] @relation("Receiver") // ich habe diese Freundschaft erhalten

  // verlinkung der Eltern -> das sind Selfrelations
  parent1       User? @relation("Parent1", fields: [parent1Id], references: [id]) // hier wird dann eingetragen wer der erste Elternteil ist
  parent1Id     Int? // hier wird dann eingetragen wer der erste Elternteil ist

  parent2       User? @relation("Parent2", fields: [parent2Id], references: [id]) // hier wird dann eingetragen wer der zweite Elternteil ist
  parent2Id     Int? // hier wird dann eingetragen wer der zweite Elternteil ist
  
  childrendAsParent1 User[] @relation("Parent1") // hier wird dann eingetragen wer der erste Elternteil ist
  childrendAsParent2 User[] @relation("Parent2") // hier wird dann eingetragen wer der zweite Elternteil ist

  // all children: const allChildren = [...user.childrenAsParent1, ...user.childrenAsParent2];

  writtenPosts    Post[] @relation("UserPosts") // geschriebene Posts
  publishedPosts Post[] @relation("PublishedByUser") // veröffentlichte Posts
  writtenComments  Comment[] @relation("UserComments") // geschriebene Kommentare
  writtenRatings Rating[] @relation("UserRatings") // geschriebene Bewertungen

  // Articles, Posts (written / moderated)
  moderatedPosts   Post[] @relation("ModeratorPosts") // wenn ein Moderator einen Post moderiert
  moderatedComments Comment[] @relation("ModeratorComment") // wenn ein Moderator einen Kommentar moderiert

  // Admin Meta
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  verified        Boolean     @default(false) // means this user has verified his email

  // deletions
  isDeleted       Boolean     @default(false)
  deletedAt       DateTime?
  deletedBy       Int? // userId -> hier wird dann eingetragen wer den User gelöscht hat
  deletedByUser   User?       @relation("UserDeletedBy", fields: [deletedBy], references: [id]) // userId -> hier wird dann eingetragen welcher moderator den User gelöscht hat
  deleteReason    String?
  deactivated     Boolean     @default(false)

  // gegen entinitäten
  deletedPosts     Post[]     @relation("PostDeletedBy") // alle Posts, die dieser User gelöscht hat
  deletedComments  Comment[]  @relation("CommentDeletedBy") // alle Kommentare, die dieser User gelöscht hat
  deletedRatings   Rating[]   @relation("RatingDeletedBy") // alle Bewertungen, die dieser User gelöscht hat
  deletedUsers     User[]     @relation("UserDeletedBy")

  // hier wird dann eingetragen ob er sich beworben hat, ob er angenommen wurde, ob er abgelehnt wurde (Bewerbung, angenommen, abgelehnt)
  status          ApplicationStatus @default(PENDING) // Bewerbung, angenommen, abgelehnt
  authorizedBy    Int? // userId -> hier wird dann eingetragen wer den Autor angenommen hat
  authorizedAt    DateTime? // hier wird dann eingetragen wann der Autor angenommen wurde
  denyingReason   String? // hier wird dann eingetragen warum der Autor abgelehnt wurde

  // besonderheiten für Moderatoren
  moderatedBy     Int? // userId -> hier wird dann eingetragen wer den Moderator angenommen hat
  moderatedByUser User? @relation("ModeratedByUser", fields: [moderatedBy], references: [id]) // hier geht um bearbeitete Profile
  moderatedAt     DateTime? // hier wird dann eingetragen wann der Moderator angenommen wurde
  moderatedUsers User[] @relation("ModeratedByUser")
  handelTickets   Ticket[] @relation("WorkedByUser") // hier werden alle Tickets gespeichert
}

enum UserRoles {
  ADULT
  CHILD
  AUTHOR
  MODERATOR
  ADMIN
}

enum ApplicationStatus {
  PENDING // Bewerbung
  ON_PROBATION // in der Probezeit
  ACCEPTED // angenommen
  REJECTED // abgelehnt
  BLOCKED // blockiert
}

model Friendship {
  id            Int @id @default(autoincrement())
  
  initiatorId  Int
  receiverId    Int

  initiator    User @relation("Initiator", fields: [initiatorId], references: [id]) // userId -> hier wird dann eingetragen wer die Anfrage gesendet hat
  receiver      User @relation("Receiver", fields: [receiverId], references: [id]) // userId -> hier wird dann eingetragen wer die Anfrage empfangen hat

  createdAt     DateTime @default(now())

  @@unique([initiatorId, receiverId]) // einzigartige Freundschaft um doppelte Anfragen zu vermeiden
}

model FriendRequest {
  id              Int @id @default(autoincrement())
  senderId        Int // userId -> hier wird dann eingetragen wer die Anfrage gesendet hat
  receiverId      Int // userId -> hier wird dann eingetragen wer die Anfrage empfangen hat
  
  sender          User @relation("SendRequests", fields: [senderId], references: [id])
  receiver        User @relation("ReceivedRequest", fields: [receiverId], references: [id])
  
  status          FriendRequestStatus @default(PENDING)
  createdAt       DateTime @default(now())
  responsedAt     DateTime?

  @@unique([senderId, receiverId]) // einzigartige Freundschaft um doppelte Anfragen zu vermeiden 
}

enum FriendRequestStatus {
  PENDING // Anfrage gesendet
  ACCEPTED // Anfrage angenommen
  REJECTED // Anfrage abgelehnt
  BLOCKED // Anfrage blockiert
}

model UserFile {
  id              Int @id @default(autoincrement())
  
  // Fixed one-to-one relation with User
  user            User? @relation(fields: [userId], references: [userFileId])
  userId          Int? @unique
  
  tickets         Ticket[] @relation("UserFile") // hier werden alle Tickets gespeichert
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt 
}

// ticket kann man im Support erstellen, und dann wird es noch eine meldefunktion geben, als Report
model Ticket {
  id             Int @id @default(autoincrement())
  
  userFileId     Int // die id der Userakte
  userFile       UserFile @relation("UserFile", fields: [userFileId], references: [id])
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  status         TicketStatus @default(OPEN)
  quickDescription String // kurze Beschreibung
  description    String //  Beschreibung

  // moderatoren
  workedById   Int?
  workedBy     User? @relation("WorkedByUser", fields: [workedById], references: [id])
}

enum TicketStatus {
  OPEN
  CLOSED
  IN_PROGRESS
}

model Post {
  id             Int @id @default(autoincrement())
  title          String
  content        String
  image          String? // optional | claudinary
  tags           String[] // array of strings
  ageRestriction Int // notwendig da wir für unterschiedliche Altersgruppen unterschiedliche Inhalte haben
  isCertifiedAuthor Boolean @default(false) // wir wollten das Pädagogische Authoren Hervorgehoben werden

  // Capital Controlling | self-relations
  preCapital     Post? @relation("PrePostRelation", fields: [preCapitalId], references: [id])
  preCapitalId   Int? // wenn es einen Vorgänger gibt, dann wird hier der Vorgänger eingetragen
  nextCapitalPosts Post[] @relation("PrePostRelation") // added opposite relation field

  nextCapital    Post? @relation("NextPostRelation", fields: [nextCapitalId], references: [id])
  nextCapitalId  Int? // wenn es einen Nachfolger gibt, dann wird hier der Nachfolger eingetragen
  prevCapitalPosts Post[] @relation("NextPostRelation") // added opposite relation field
  
  capital        Int? // wie viele Kapitel der Artikel hat hat

  authorId       Int
  author         User @relation("UserPosts", fields: [authorId], references: [id])

  moderatorId    Int?
  moderator      User? @relation("ModeratorPosts", fields: [moderatorId], references: [id])

  published      Boolean @default(false)
  publishedAt    DateTime?
  publishedBy    Int? // userId
  publishedByUser User? @relation("PublishedByUser", fields: [publishedBy], references: [id]) 

  // comments & Ratings
  comments       Comment[] @relation("PostComments")
  ratings        Rating[] @relation("PostRatings")

  // admin meta
  isDeleted      Boolean @default(false)
  deletedAt      DateTime?
  deletedBy      Int? // userId
  deletedByUser  User? @relation("PostDeletedBy", fields: [deletedBy], references: [id]) // userId -> hier wird dann eingetragen wer den Post gelöscht hat
  deleteReason   String?

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model Comment {
  id             Int @id @default(autoincrement())
  postId         Int // zu welchem Post gehört der Kommentar
  post           Post @relation("PostComments", fields: [postId], references: [id])
  userId         Int // wer den Kommentar geschrieben hat
  user           User @relation("UserComments", fields: [userId], references: [id])

  content        String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  moderatorId    Int?
  moderator      User? @relation("ModeratorComment", fields: [moderatorId], references: [id])

  isDeleted      Boolean @default(false)
  deletedAt      DateTime?
  deletedBy      Int? // userId
  deletedByUser  User? @relation("CommentDeletedBy", fields: [deletedBy], references: [id]) // userId -> hier wird dann eingetragen wer den Kommentar gelöscht hat
  deleteReason   String?
}

// model muss noch überarbeitet werden
model Rating {
  id             Int @id @default(autoincrement())
  postId         Int
  post           Post @relation("PostRatings", fields: [postId], references: [id])
  userId         Int
  user           User @relation("UserRatings", fields: [userId], references: [id])

  rating         Int
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  isDeleted      Boolean @default(false)
  deletedAt      DateTime?
  deletedBy      Int? // userId
  deletedByUser  User? @relation("RatingDeletedBy", fields: [deletedBy], references: [id]) // userId -> hier wird dann eingetragen wer den Kommentar gelöscht hat
  deleteReason   String?
}